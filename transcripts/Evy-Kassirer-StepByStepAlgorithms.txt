      "Step by Step - Algorithms that teach you math!"
      By: Evy Kassirer.
      >> Hi, everybody.  Hi.  Thanks for coming.  There's so many awesome talks going on.  Thanks for your interest.  I'm assuming you are here because you entrusted in math education or at the least, how could you write an algorithm that teaches people math in a, like, human-like way?  Which is what we'll be talking about today.
      All right.  I'll just click the button.
      So before we dive in, I want to just, like, take a step back and talk for a minute about how do humans think about math?  Because to write an algorithm that solves math like a human would, we first have to figure out how a human would think about math.  So here's some math.  I don't know about you, but when I look at this, I don't just see a bunch of characters.  It's not just a bunch of characters like a two and a zero and a plus sign.  And then when you're looking at a book, you group them together with words and the words become sentences, and you read them with some kind of tone.  That's because you've learned rules about how the English language work or other languages, so you also have rules in your mind for how math works, so I know that division happens before addition, and I group that together in my mind, and I know that that happens first and 8 divided by 4 is 2, and I can add that to 20 and get 22.  I do that all without thinking at all.  I just know it's 22 because my mind knows all of these rules and I can apply them quickly.
      Here's more math.  I'm sort of curious.  I think your mind applies more meaning to this than there is it just in the characters too.  Do you see the 2X as a unit?  Like, do you see it 2X over three?  There's no parentheses over the 2X, but you're probably still seeing it as a unit as 2X.  Or maybe you see it as 2X over 3.  Who sees it as the one on the left?  Awesome.  One on the right?  Cool.
      So we do the one on the left and that's good because that's more likely to be how you're thinking about it.  Or maybe you see it as, like, two-thirds X.  And you might be wondering -- nice.  Yeah, anyone that wasn't either that I showed?  Cool.
      And you might be wondering, like, what -- why does it matter?  These are all mathematically equivalent.  I think when you show a step-by-step solution to be able to just print it on the screen in the right way that they're thinking about it is important.  But also being able to, the step by step solution is important.  The one on the left, that's a fraction, the one on the right is a number times a fraction, so you what you might do is different.
      I think if there's a space here, it might change the way you Parse it.  Like, does this change anyone's answer, maybe?  Yeah, I think that would be the one on the right.  But then weird questions of, like, what if it's two plus X thirds?  Like, a mixed fraction or something.  And now this is a different math thing and anyway, the point is a string of math, which is the input to this algorithm we're going to be talking about, can be interpreted by our minds in lots of different ways and thinking about how humans think about math is kind of what we're going to be getting into.
      So thinking about how do humans bank account and solve math?  How could an algorithm solve math?  And can algorithms follow the same logic that a human would?
      What will we be talking about?  All great questions.
      So today, we're going to be talking about -- I'll start by introducing myself.  We'll talk about why math steps, which is this algorithm why it was built.  And how it was built, and not just how it produces some step by step solution, but a step-by-step solution that can provide a good learning experience.
      We'll talk about some of the limitations of math steps because all technology has its flaws and its limitations.  And we'll also talk about the future of math steps and, like, things that could be done with tech to do stuff for math education.
      So let's get into it.
      My name is Evy.  Hello.  I'm a computer science student at the University of Waterloo, and I'm really interested in education.  I'm currently interning at Asana on their infrastructure team.  But being a Waterloo student, I've done a whole bunch of internships.  More than on this slide.  And in general, I'm interested in working on technology that help people think about things and working on technology that does social good, and that's sort of why I started working on this at one of my internships at a company called Socratic.
      So-socratic is an app.  I work there a years ago, and they make an app where they take a picture of your homework, it scans it, it figures out what you're asking, what subject it is, and then it provides you a bunch of teaching resources to learn more about that topic and help you solve your homework.
      And when I got there, they were, like, just thinking about doing math stuff.  So they were, like, oh, turns out half of our queries are math because everyone takes math.  Everyone takes it, like, every year of school and once you get one part that's kind of challenging, you're, like, screwed for the rest of -- your educational career because everything builds on each other.  And a lot of people just end up having a lot of trouble with math.  It was something that I really enjoyed.  Like, I was able to have really good teachers and resources, and I really enjoy, like, showing my work and doing math.  But a lot of people don't, and they come to the app to some math questions, so we wanted to provide a step-by-step solution.
      A good step by step solution.  And how do we define good?  It should be detailed, which means not just here's the answer, but, like, some steps along the way of how that happened.  It should have good explanations.  So, like, why that step happened?  And it should be intuitive.  Because there's lots of ways to get to the answer, but some of them a human will be, like, well, why did you -- that makes no sense.  And some of them will be intuitive based on of how they learn to do it at school and stuff.  And it should pretty much be like a human tutor but not human.  And then this is what it looked like in the Socratic app when I finished my internship.  It scans, like, a picture of math, which is not part of math steps at all.  It's just really cool, so I just wanted to show you.  This math OCR and then takes that and then has this step by step solution that you can look through.
      I wanted to mention that math steps only does algebra right now, so it's simplifying expressions, solving equations, the Socratic app has a private fork of the code, and they added some calculus support, but that's kind of the extent.  The scope of what we'll be talking about today.
      So you might be wondering, there's already step by step math solvers out there.  Why build a new one?  And the main answer is we wanted something that we could use and all of the existing ones are closed source.  So we built our own and then made it open source so that other people can also work on it and make it good and stuff like that.  It's also worth noting that, like, even some of the existing math solvers out there, like, Wolfram Alpha, not free anymore.  It was free when I was doing integrals.  But now if you want an integral step by step solution, you have to pay, like, two bucks a month for it or something.  And we wanted to make sure that we were focused on teaching.  So there's existing open source software out there that does stuff related to math or solving math.  But it doesn't necessarily show a step-by-step solution or doesn't, like, focus on the teaching aspect of it.  So as far as I know, math steps is the first open source teaching math solver.  Which is exciting.
      So at this point, you might be wondering.  How do we build it?  And that's what we're going to talk about next.
      So the input is ASCII math just, like, letters and numbers and symbols that you can type out on the keyboard.  That's parsed into a Parse tree, and then you iterate over that tree a bunch of times, applying a bunch of different possible simplifications.  And then at some point there's no more simplifications that can be done and then we reached the most simplified form which, again, all of these things are kind of arbitrary, but we'll get into that.
      So the first part, parsing input.  This is kind of what I meant by ASCII math.  So you can see here, like, the two for X squared, it's not, like, a little tiny two in the corner.  It's literally X carrot two.  So these are things that you can type out on your keyboard.  And when you look at this, you might think, oh, I can see that that one plus two is in parentheses and your mind kind of groups that into a chunk.  Or you see the minus three, and you know that's an argument of the absolute value function.  Or you could use your knowledge of order of operations and know that the multiplication part happens before the subtraction part.  How could we put this into some data structure that a computer can also apply this knowledge?  A Parse tree -- okay.  So math JS is this really awesome open source math library, and they have a really great parser, and it makes this tree, and it was really helpful, and math JS is great.  And so the way this works, you can see here, like, the one plus two is in its own subtree.  The minus three is a argument to the absolute value function.  So all kinds of things that you parsed in your mind was also parsed into this tree.  And that becomes really helpful for the algorithm.
      At this point, I kind of wanted to go back to that thing I said earlier where there's existing open source math tools that are not necessarily suited for, like, a step-by-step solution or for something focused on teaching.  And here's, like, a really good example.
      So computer algebra system is a really cool piece of technology.  It takes in math, like, a string of math, and it can simplify or solve things for you and a bunch of other stuff.  And me going into this project I was, like, oh, I'll just take this and look in the code and, like, find each step by step part and, like, take that out because of course a computer is doing something like a human does.  Nope.  Not at all.
      So I was looking at a Python computer algebra system and when I parsed X minus Y plus two-thirds, it immediately turned it into this other tree, which was X plus minus one times Y, which is, like, kind of, like, minus Y but not.  Plus two times three, two minus one.  So there's no more division.  There's only multiplication by the inverse, and I was, like, well, this is great.  Now if I want to do a step-by-step solution, I have, like, no idea what the user inputted originally and, like, how do -- there's just no way.
      And I was confused at first why some might do that.  But, honestly, their goal is to get to the solution and if they don't have as many operations, now they only have addition, multiplication, and exponentialation, there's no more division or subtraction, so there's less stuff for them to deal with.  So it's better for their goal and the goal of the computer algebra system is the answer.  Our goal is a step by step solution, so even as early in, like, the algorithm design as just, like, what data structure we're going to use, we're already going down different paths.
      Another thing that came across while designing our tree was realizing that arithmetic options are binary.  And by that I mean I was scanning two plus three plus four, like, putting that through the parser, I was expecting, like, one plus node with three children two, that is right, and four.  But instead, I got, like, two plus three plus four or two plus three plus four.  I was, like, why is this tree binary?  Why -- that doesn't make sense to my, like, the way I think about math.  And turns out that's, like, actually the way the plus operator is defined.  It's an addition of the left side of the plus operator and the right side of the plus operator, and that's, like, how it works.
      But because plus and also multiplication, they're both commutative and associative, we think of it in our minds as just an binary operation, and it can have any number of arguments.  And I was, like, okay.  This tree is fine, like, we'll see what happens.  And then I got to something like this, and this kind of thing comes up a lot.  Collecting and combining like terms, you find the two Xs and combine them together and two, twos and add them together, and it was really hard with a tree that was all spread out like that when you have a binary tree, and you have to, like, kind of iterate over it and figure out what arguments are candidates for collecting, and it was not fun, and I was, like, well, the way we do it as humans is we just look at all of the things that are added together for things that are similar, so we flatten the tree, and it was way easier or actually converting over to a new parser soon that my friend Kevin is working on, and it will Parse the tree automatically and flatten it automatically as its parsing, which I'm excited about.
      So we have a tree.  That's great.  Now we need to do the steps.  We need to -- a simplify things step by step.  Oh, baby.
      ¶¶¶
      Got to get to you, girl.  I didn't know the song until I got to my internship and then was singing it for four months.  I just wanted to share that.
      So now we're simplifying things step by step.  The reason that simplification is such a big thing, this is most of what math steps does.  There's lots of other things you can do in math, but I think at the end, usually, you're simplifying your answer or a lot of, like, cool things that students have in early school or, like, mid- -- middle school is around simplifying stuff.
      So that's what we focus on.  And an example of a simplifying rule would be something, like, something to the zero simplifying to one or taking two numbers and adding them together.  Or the one in the bottom right as, like, combining the 2X and the X to become 3X.  And the way that we match a rule like this is with a tree search.  So, for example, the rule something to the zero becoming one, you can go through the tree, try to find something that's an exponent node and then try to see whether the exponent is zero and if both of those things are true, then you can replace that whole thing with a one.  And that's how, like, all of the rules work.  It looks through the tree, tries to find a matching rule, and then it will, like, replace that with whatever the simplified version is.
      As a note, for those of you that are, like, but what if it's zero to the zero, that's undefined.  I know.  And we don't do anything about it right now.  But it's on my mind and, like, adding capabilities for catching errors and, like, how that would work and what it would return and stuff is something we're exploring right now, so you're welcome to contribute to that.
      So that's pretty much how it works.  We have some ASCII input, we Parse it, we do a bunch of tree searches to try to match rules, and we simplify.  So we can have a step-by-step solution now.  But I don't think that that's, like, the most interesting part of this.  I think the part that gets really neat is not just a step-by-step solution but a good one.  One that has steps that are, like, intuitive and, like, teach well.  And so there is, like, so many things that we could do to do that and lots that we haven't done yet.  But I want to share some of the things that we've done so far.
      So one thing is the way that we structure the tree search, so we were just talking about tree searches here.  Yeah.  So searching through the tree, matching a rule.  There are two different ways that you can do that search.  One is a post order search, which tests the parent for the rule post its children, so look at the children first.  If the rule didn't match, then you check the parent.  A preorder search will check the parent first.  And that can change how the solution looks.
      So for the rules something to the zero is one, if we were using a post order search and looking at the children first, and someone inputted something like X to the zero to the zero, which I know doesn't really make any -- like not that many people would ask that, but it's possible.  What that would simplify to is look deeper in the tree first, and it would match more to the inside X to the zero, so you have X to the zero to the zero becoming one to the zero, and then the next time it would become one.
      But if we had a preorder search, it could just become one right away, which I think makes more sense.  It, like -- if you have a really big expression all to the power of zero, and you can just make that one.  And algorithms, often, we, like, take shortcuts if we can and not do extra work in teaching sometimes they're not doing extra work thing is not great for teaching, but I think in this case it does make sense, so that search is in math steps as preorder search.  But some searches are better as post order searches.  For example, adding numbers together is only going to match to the bottom of the tree, so it may as well look at the bottom of the tree first.  And that is more efficient.
      So some post order, some preorder for, like, algorithm efficiency sometimes.  But mostly just for, like, optimizing learning, like, in this case.
      Another question I get a lot is, like, how do you choose which simplification to happen first?  This is, like, a screen video of the -- our code, and this is, like, all the different rules that you can possibly match.  There's, like, a whole bunch of them, and it's only a very small subset of existing math.  And how do we pick which one happens first?  Like, often, it's arbitrary.  But there are reasons why sometimes we do certain rules first.
      So this is how it's structured in the code.  We have this list of tree searches, each, like, group is a certain category of search.  So the first one is basic searches.  So the one that we just saw.  Something to the zero is one.  May as well do that first because if that's the whole question, then we're done.  Or something, like, something times zero is zero.  Or something times one is itself.  Just clean that up at the beginning, and that's why that one -- those searches happen first.  None of those rules can be matched anywhere in the tree, then we go onto this next one that I just like to put high up because I really don't like the way that that works, like, two over X over six.  It's really weird to look at, but it's legal to Parse, so someone could put that in there, and you can just multiply by the inverse, and that standardizes that the way it looks, and the algorithm can assume that a fraction won't have a numerator or denominator that's also a fraction.  That's confusing.
      Another thing that we do to teach well is that good teaching isn't necessarily the most simple or basic or fewest steps.  Sometimes, you can show a bit more detail.  So here, we have, like, X times X squared becoming X cubed.  And even in writing the code for this, I was, like, where does the three come from?  I need to figure out what the new exponent is, and I think it would be the same for the human that is trying to learn this for the first time or still working on it.
      And the answer is you add the exponents together.  But then you might be, like, where did that one come from?  There's no one.  X is the same as X to the one, and then you can add the one with two together, and then you get three, and that was something that I had to do in programming it, and it's also something that, like, a human might need to know, so it's important to, like, expose those steps and show those details when it's something new to someone so that they can understand it.
      Pretty much just, like, goals teaching theory makes things more complex, so it could have more goal, there could be more output, but that creates a better learning experience, so we'll do that.
      However, complexity can make things more complex.  And we had this technical complexity issue here where we were having these steps for adding fractions.  It's, like, a thing that a lot of students have trouble with.  There's a lot to it.  The first step is to work towards having a common denominator, and you might notice that, like, in that process, it gets a little bit less simplified, even though toward something that's more simplified.  So at this point, in math steps, we were just doing one step, and then without any context, figuring out what the next step was.  So just keeping it going through, coming up with a new rule that matches.
      But that gets a little weird here because two times five over three times five without any, like, context, you cancel the fives and then you say I need to add fractions and multiple the top and bottom and those fives need to be canceled out.  And I'm, like, no, what are we going to do?  And then I tried to move the order of the rules around so that the right thing would happen first before the other thing but then other things broke, and I was, like, how do humans know what to do?  They know know that they're in the middle of adding fractions.
      So now we just group all of these steps together.  We know that we're adding fractions, and then we do all of the steps in sequence, and then return them all together as substeps of the step adding fractions.  And this is awesome for, like, so many reasons.  One of them is to avoid this infinite loop situation.  Another one is we don't have to do all the work going through all the possible steps to figure out what's happening next.  We know what's going to happen next.  We're adding fractions.  That's the next thing that happens.  And it also is really nice for -- this is the demo.  A screenshot of it.  You can collapse the subsets.  So let's say you know how fractions work and you don't want to see the details, you don't have to see the details.  You can collapse them or maybe you want to know how it works, and you can expand it.  It just gives more context for what's going on, which is great when there's a lot of steps, and you don't understand that math, you can, like, pick and choose when to see certain details.
      And this is really helpful for this case too.  I said the bottom line was best when you don't know how this math works.  But if you know that X is the same as X to the one, having that show us a step every time can be really annoying.  So having the option to show that as detail is really awesome.
      So now we've talked about a bunch of ways that Mathsteps teaches well.  But there are also a lot of ways that it could teach better or just limitations of things it can never do.  And I want to make sure that, like, in my talk, imaging that I talk about the limitations of technology because, like, technology isn't going to make the world perfect and just a step-by-step solver, like, solve all of math education, so I want to make sure that I talk about that.
      So this is kind of come up a couple of times.  Like, how many steps do you show?  Like, sometimes if you show a lot of steps, people, like, really like that, and they like to see all the details.  Sometimes if you show, like, 30 steps, the student will be, like, nope.  Math is hard.  That's too much.  I don't like it.  Put it away, and they'll be scared off.
      Maybe they know a bunch of details of something, and you don't need to show that to them, like, they already know how that works.  And it's boring or annoying.  Or maybe there's something that you don't show them that, like, is very key for them understanding how it works.  So how many steps to show just, like, depends on the problem, which you do have and the student, which you know nothing about because it's just an algorithm.
      Different people solve math differently.  This also -- so this could be, like, the final solution.  Eight over five.  And we can show eight over five as an improper fraction.  But in grade three, I was told to leave it as a mixed fraction.  In university, I was told to leave it as a decimal.  So people might be looking for a specific answer and maybe we're not giving them that answer because we have no idea what they want, unless we ask and mathstep doesn't ask right now.  We also don't ask how they want to solve the question.  So we might -- so there's, like, the answer, but there's also all of the steps along the way.  So when I see this, this is, like, multiplying two binomials the way I learned to do it was you take the first term, you multiply it by all the terms on the right, then you take the second one and multiply by all the terms on the right.  If there was a third term, I would also multiply by all the terms on the right.  I know how to expand this to any kind of multiply things by each other.  But a lot of people learned this as foil.  Did anybody learn it as foil?  There's the first, outer, inner, and last.  And that's how you know what the answer is.  Until you add a third term in the parentheses, and then students are, like, I have no idea what to do because they don't know how the math works.  It teaches -- it's a way to memorize how this math works, but it's not, like, the why.  And so they can't really, like, expand that.  And so I tried to avoid pneumonics in Mathsteps because I feel it's not a great teaching tool.  But also some people might get confused because different people solve math differently.  And it's, like, use foil to answer these questions.  And I'm liked it am I supposed to use foil here?  They don't mention foil at all.  What's going on?
      And then close it.  So there's this weird balance between relevant and useful to the education system, like, stuff that they're learning in school and stuff that is relevant to, like, the education system as it is right now, which has its flaws.  And then there's, like, teaching to help learning, which is, like, some best way of teaching where, like, we're really, like, helping people understand how it works.  And then there's totally different ways to teach math and different fundamentals of learning, and that would be, like, really cool but anyone use it?  Would it be helpful to anyone?  There's some balance there.  So that's, like, really hard.  But is there even a fast way of solving something or teaching something?  I don't think it's really objective.  So a lot of the stuff that we do in Mathsteps is arbitrary.  Or it's at least what we think is the best.  And sometimes it's just -- this one teams fine.
      And finally, when we're talking about a limitations, a step-by-step solution isn't a full teaching tool, it's just a cool technical problem.  It's not a lesson plan or, like, a full in-depth explanation why.  It's not going to fix all of math education.  It's just a tool that can be used, like, within the system.  And people use it to solve their homework, which means it can be used to cheat.  I don't know if any of you used Wolfram Alpha or these things to, you know, Oh, I don't know how to do that integral, and I need to get some step by step solution that will teach me how to do it.  We all have done it, I think, and it is a thing that this kind of technology is used for, so I just, like, keep it in mind.  But there are things that we can do that can make this kind of technology better for learning, and there are things that this kind of technology could maybe -- things that could be built on top of it that could also help.  So lots of cool opportunities for stuff in the future.  And I'm going to talk about a little bit now.
      So when we do a tree search, we know that we're adding fractions at this point.  Wouldn't it be cool if since we know you're adding fractions, be, like, hey, check out this video on how to add fractions.  Or even a substep, like, hey, do you want to learn more about least common multiple?  Here's a video about it because we know this information.  We're, like, matching these rules already.  Or what if we're, like, hey, you're adding fractions.  This person over here is also adding fractions.  You want to talk about adding fractions together?
      [Laughter]
      I mean, it's, like, silly in this example but also, teaching your peers and, like, talking about the problems that you're having with each other is one of the best ways to learn.  So I think it would be really cool if people could -- if we knew that a group of people are all working on the same kind of math to give them a place to talk about that with each other.  Because learning with other people is better than just learning by yourself and copying down the answer; right?
      Ways to learn how much detail to show.  This comes up a lot.  I think there's a couple of different ways that we could do this.  You could notice, like, when do they expand substeps?  When do they really want to see more detail?  Maybe we could keep that expanded by default.  Or maybe you can look at the whole question and be, like, is this just a very small part of this very big problem?  Then they probably don't need the details at all.  But if they're just asking them that particular thing, then you can show them the details.  Or you could just ask them, hey, is this kind of thing a thing that you know?  And they're, like, "yes." and you can stop giving them how to do that part.
      And then eventually you can get to know the learner, and you can only show them exactly the steps that are pretty useful to them, which is pretty much what human tutors do, and I think that's a lot of what is missing in Mathsteps is getting to know the learner and being able to personalize things a little bit more.
      Another thing that I think would be really cool for Mathsteps to do is get more context than just a string of math because liked an equation, you can solve it, you can also graph it, you can also factor it, which one do they ask?  Just solve the equation and hope that's what they were asking for.  Or even what variable with respect they solving for?  And often, when people are, like, doing this kind of homework, they have written at the top some words that explain what the question is.  So it would be great to have that context as well because that's how humans usually solve math.  Not just a string.  There's, like, instructions that go along with it.
      So there's more than just the string.  More than just this tree.  Like, how can we expand this data structure to show more information?  Another example of more information you might want is let's say we have an equation like this, and we're dividing by X minus three on the top and the bottom.  At this point, you just have X plus five equals zero.  But some of you might be, like, don't forget.  X can't equal three because if it did, you would be dividing by zero.  I forgot this a lot in high school.  This is, like, one of those educates things.  But if this was the question, there would be no solution.  And if you didn't remember that X can't be three, you would be lying, which I think Mathsteps does right now.  So you want to be careful to, like, keep this extra information of what the range of certain variables can be, and there's lots of stuff that comes up like this.  Things that aren't just in the expression that you want to store because that's how humans solve math.
      This one's my favorite, but I feel people never use it or you make them guess.  This is what a human tutor can do.  They sit you down, and you have no choice.  They're, like, what do you think comes next?  They're, like, just guess, and you're, like, okay.  That's how you learn.  But if this is in an app, you're, like, like, no screw this.  I'm going to use Wolfram Alpha.
      So some kind of balance.  But definitely, this is a great way to learn.
      And finally, machine learning.  It could be cool to, like, train some kind of, like, model, take a bunch of examples of good step by step solutions, whatever good means, I don't know.  And then train on that, and then you could, like, provide a step-by-step solution for any problem.  I have no idea if this is possible or how it would be done or if we have enough technology for it to provide, like, really good step by step solutions.  But if any of you are, like, interested in machine learning and have ideas about it, I would love to chat more about it because it's, like, kind of neat to think about.
      So now we talked about all the cool things that you can do with Mathsteps, you might be wondering this is so cool.  I wish I could contribute to it, and it's open source, so you can.  It's written in JavaScript.  It's just pure, like, an algorithm.  And you can find it at that URL.  We have a bunch of small tasks that should be accessible to someone that even knows barely anything about the project, and you already know a lot about how it works now, so you're past that point anyways.  We have a bunch of really great tests.  They're cool because it can be, like, a string that is parsed, and then it does a bunch of steps and prints it at the end.  So all of them are, like, this string becomes that string, and it's pretty much a step-by-step solution that you can figure out and see how the step by step solution works.  So you can see how math steps does all of the things it does by just looking at the tests.  And we have the contributing document, there's lots of improvements.  We already talks about some of the things that Mathsteps could do, that you could work on, bug fixes, or even if you want to talk about algorithm design and writing algorithms that are optimized for teaching, I would be down to chat about that any time.  Here's are some numbers to show how popular we are.
      But more important than that, look where all of our contributors are from.  Like, a cool community from around the world.  If you're from any of the countries that don't have a pin on them, you should contribute.  And if your country is not on this map because I cropped it, I'm sorry.  Especially if you're from Australia.
      [Laughter]
      So we have a demo that I just made, like, this past week, so now you can, like, play with it and see how it works.  You can also download the Socratic app and see how that works.  I also it's, like, on NPM, so you can, like, install it and play with it, or you can just fork it and edit the code and do some cool stuff and then make a pull request to contribute your code back.  And that's it.  Thank you so much for contributing and if any of you want to talk about this with me, I would love to chat.  Hope to see you around.  Thank you.
      [Applause]
      We're, like, a bit early, but you should go get lunch because you'll be early in line.  You're welcome.
      Captions provided by @chaselfrazier and @whitecoatcapxg.
